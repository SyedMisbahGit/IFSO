<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDS Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.js"></script>
    <style>
        .packet-table-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e2e8f0; /* Tailwind border-gray-300 */
            border-radius: 0.375rem; /* Tailwind rounded-md */
        }
        .alert-item {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Custom scrollbar for better look */
        .packet-table-container::-webkit-scrollbar {
            width: 8px;
        }
        .packet-table-container::-webkit-scrollbar-track {
            background: #f1f5f9; /* gray-100 */
            border-radius: 4px;
        }
        .packet-table-container::-webkit-scrollbar-thumb {
            background: #cbd5e1; /* gray-300 */
            border-radius: 4px;
        }
        .packet-table-container::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; /* gray-400 */
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-900 font-sans">
    <div class="container mx-auto p-6">
        <h1 class="text-4xl font-bold text-center mb-8 text-blue-700">Intrusion Detection System</h1>

        <div class="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-blue-600">Controls</h2>
            <div class="flex space-x-4 mb-4">
                <button id="startSniffBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded transition duration-300">
                    Start Sniffing
                </button>
                <button id="stopSniffBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition duration-300">
                    Stop Sniffing
                </button>
            </div>
            <p id="statusMessage" class="text-gray-700 mt-2"></p>
        </div>

        <div class="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-blue-600">Manage Rules</h2>
            <div class="mb-4">
                <label for="ruleName" class="block text-sm font-medium text-gray-700">Rule Name:</label>
                <input type="text" id="ruleName" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500" placeholder="e.g., Block_WhatsApp">
            </div>
            <div class="mb-4">
                <label for="ruleType" class="block text-sm font-medium text-gray-700">Rule Type:</label>
                <select id="ruleType" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
                    <option value="alert">Alert</option>
                    <option value="block">Block</option>
                </select>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div>
                    <label for="targetProtocol" class="block text-sm font-medium text-gray-700">Protocol (e.g., tcp, udp, icmp, all):</label>
                    <input type="text" id="targetProtocol" value="all" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div>
                    <label for="targetIp" class="block text-sm font-medium text-gray-700">Target IP (e.g., 192.168.1.1, any):</label>
                    <input type="text" id="targetIp" value="any" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div>
                    <label for="targetPort" class="block text-sm font-medium text-gray-700">Target Port (e.g., 80, 443, any):</label>
                    <input type="text" id="targetPort" value="any" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
                </div>
            </div>
            <div class="mb-4" id="directionField" style="display: none;">
                <label for="direction" class="block text-sm font-medium text-gray-700">Direction (for Block rules):</label>
                <select id="direction" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
                    <option value="inbound">Inbound (traffic coming IN)</option>
                    <option value="outbound">Outbound (traffic going OUT)</option>
                    <option value="both">Both</option>
                </select>
            </div>
            <button id="addRuleBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition duration-300">
                Add Rule
            </button>

            <h3 class="text-xl font-semibold mt-6 mb-3 text-blue-600">Active Rules</h3>
            <div id="activeRulesList" class="bg-gray-50 p-4 rounded-md border border-gray-200">
                <p class="text-gray-600">Loading rules...</p>
            </div>
        </div>

        <div class="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-blue-600">Real-time Traffic</h2>
            <div class="packet-table-container">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50 sticky top-0">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Timestamp</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Source IP</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Destination IP</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Protocol</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Src Port</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Dst Port</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Length</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Info</th>
                        </tr>
                    </thead>
                    <tbody id="packetTableBody" class="bg-white divide-y divide-gray-200 text-sm">
                        </tbody>
                </table>
            </div>
            <p class="text-gray-600 mt-4">Total packets displayed: <span id="packetCount">0</span></p>
        </div>

        <div class="bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-blue-600">Alerts</h2>
            <div id="alertsList" class="space-y-3">
                <p class="text-gray-600">No new alerts.</p>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        const packetTableBody = document.getElementById('packetTableBody');
        const packetCountSpan = document.getElementById('packetCount');
        const alertsList = document.getElementById('alertsList');
        const startSniffBtn = document.getElementById('startSniffBtn');
        const stopSniffBtn = document.getElementById('stopSniffBtn');
        const statusMessage = document.getElementById('statusMessage');
        const addRuleBtn = document.getElementById('addRuleBtn');
        const ruleNameInput = document.getElementById('ruleName');
        const ruleTypeSelect = document.getElementById('ruleType');
        const targetProtocolInput = document.getElementById('targetProtocol');
        const targetIpInput = document.getElementById('targetIp');
        const targetPortInput = document.getElementById('targetPort');
        const directionField = document.getElementById('directionField');
        const directionSelect = document.getElementById('direction');
        const activeRulesList = document.getElementById('activeRulesList');

        let packetsDisplayed = 0;
        const MAX_PACKETS = 500; // Max packets to display in real-time table

        // --- SocketIO Event Handlers ---
        socket.on('connect', () => {
            console.log('Connected to server');
            statusMessage.textContent = 'Connected to server.';
            loadHistoricalData(); // Load initial data on connect
            loadActiveRules();
        });

        socket.on('new_packet', (packets) => {
            // packets is an array of packet objects
            packets.forEach(packet => {
                const row = packetTableBody.insertRow(0); // Insert at top for latest
                row.className = 'hover:bg-gray-50'; // Add hover effect

                row.insertCell(0).textContent = packet.timestamp;
                row.insertCell(1).textContent = packet.source_ip;
                row.insertCell(2).textContent = packet.destination_ip;
                row.insertCell(3).textContent = packet.protocol;
                row.insertCell(4).textContent = packet.source_port === 'N/A' ? '-' : packet.source_port; // Display '-' for N/A
                row.insertCell(5).textContent = packet.destination_port === 'N/A' ? '-' : packet.destination_port; // Display '-' for N/A
                row.insertCell(6).textContent = packet.packet_length;
                row.insertCell(7).textContent = packet.info;

                packetsDisplayed++;
                packetCountSpan.textContent = packetsDisplayed;

                // Keep table clean by removing oldest packets
                if (packetTableBody.rows.length > MAX_PACKETS) {
                    packetTableBody.deleteRow(MAX_PACKETS);
                }
            });
        });

        socket.on('new_alert', (alert) => {
            const alertDiv = document.createElement('div');
            alertDiv.className = 'bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-2 alert-item rounded-md';
            alertDiv.innerHTML = `<p class="font-bold">${alert.message}</p><p class="text-sm text-red-600">${new Date().toLocaleString()}</p>`;
            alertsList.prepend(alertDiv); // Add new alerts at the top
        });

        // --- Control Button Handlers ---
        startSniffBtn.addEventListener('click', async () => {
            try {
                const response = await fetch('/start_sniff');
                const data = await response.json();
                statusMessage.textContent = data.status;
            } catch (error) {
                console.error('Error starting sniff:', error);
                statusMessage.textContent = 'Error starting sniff.';
            }
        });

        stopSniffBtn.addEventListener('click', async () => {
            try {
                const response = await fetch('/stop_sniff');
                const data = await response.json();
                statusMessage.textContent = data.status;
            } catch (error) {
                console.error('Error stopping sniff:', error);
                statusMessage.textContent = 'Error stopping sniff.';
            }
        });

        // --- Rule Management ---
        ruleTypeSelect.addEventListener('change', () => {
            if (ruleTypeSelect.value === 'block') {
                directionField.style.display = 'block';
            } else {
                directionField.style.display = 'none';
            }
        });

        addRuleBtn.addEventListener('click', async () => {
            const ruleName = ruleNameInput.value.trim();
            const ruleType = ruleTypeSelect.value;
            const targetProtocol = targetProtocolInput.value.trim().toLowerCase();
            const targetIp = targetIpInput.value.trim();
            const targetPort = targetPortInput.value.trim();
            const direction = directionSelect.value;

            if (!ruleName) {
                alert("Please provide a rule name.");
                return;
            }

            const ruleData = {
                rule_name: ruleName,
                rule_type: ruleType,
                target_protocol: targetProtocol === 'all' ? null : targetProtocol,
                target_ip: targetIp === 'any' ? null : targetIp,
                target_port: targetPort === 'any' ? null : (isNaN(parseInt(targetPort)) ? null : parseInt(targetPort)),
                direction: ruleType === 'block' ? direction : null // Only send direction for block rules
            };

            try {
                const response = await fetch('/add_rule', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(ruleData)
                });
                const data = await response.json();
                alert(data.message);
                if (response.ok || response.status === 202) { // 202 for warnings
                    ruleNameInput.value = ''; // Clear form
                    targetProtocolInput.value = 'all';
                    targetIpInput.value = 'any';
                    targetPortInput.value = 'any';
                    loadActiveRules(); // Reload rules display
                }
            } catch (error) {
                console.error('Error adding rule:', error);
                alert('Error adding rule: ' + error.message);
            }
        });

        async function deleteRule(ruleId) {
            if (!confirm("Are you sure you want to delete this rule? This will also remove associated iptables rules if it's a block rule.")) {
                return;
            }
            try {
                const response = await fetch(`/delete_rule/${ruleId}`, {
                    method: 'DELETE'
                });
                const data = await response.json();
                alert(data.message);
                if (response.ok || response.status === 202) {
                    loadActiveRules(); // Reload rules display
                }
            } catch (error) {
                console.error('Error deleting rule:', error);
                alert('Error deleting rule: ' + error.message);
            }
        }

        async function loadActiveRules() {
            try {
                const response = await fetch('/get_rules');
                const rules = await response.json();
                activeRulesList.innerHTML = ''; // Clear existing list

                if (rules.length === 0) {
                    activeRulesList.innerHTML = '<p class="text-gray-600">No rules active.</p>';
                    return;
                }

                rules.forEach(rule => {
                    const ruleDiv = document.createElement('div');
                    ruleDiv.className = 'bg-blue-50 border-l-4 border-blue-400 text-blue-700 p-3 mb-2 rounded-md flex justify-between items-center';
                    let ruleInfo = `<strong>${rule.rule_name}</strong> (Type: ${rule.rule_type.charAt(0).toUpperCase() + rule.rule_type.slice(1)})`;
                    if (rule.target_protocol) ruleInfo += `, Prot: ${rule.target_protocol.toUpperCase()}`;
                    if (rule.target_ip) ruleInfo += `, IP: ${rule.target_ip}`;
                    if (rule.target_port) ruleInfo += `, Port: ${rule.target_port}`;
                    if (rule.direction) ruleInfo += `, Dir: ${rule.direction.charAt(0).toUpperCase() + rule.direction.slice(1)}`;

                    ruleDiv.innerHTML = `
                        <p>${ruleInfo}</p>
                        <button class="bg-red-400 hover:bg-red-500 text-white text-xs font-bold py-1 px-2 rounded" onclick="deleteRule(${rule.id})">Delete</button>
                    `;
                    activeRulesList.appendChild(ruleDiv);
                });
            } catch (error) {
                console.error('Error loading active rules:', error);
                activeRulesList.innerHTML = '<p class="text-red-600">Error loading rules.</p>';
            }
        }

        // --- Load Historical Data on Page Load ---
        async function loadHistoricalData() {
            // Load historical packets
            try {
                const response = await fetch('/get_historical_packets');
                const packets = await response.json();
                packetTableBody.innerHTML = ''; // Clear any loading message
                packetsDisplayed = 0;

                // Display packets (reverse to show newest first if initial load is not real-time ordered)
                // Assuming get_historical_packets returns newest first (ORDER BY DESC)
                packets.forEach(packet => {
                    const row = packetTableBody.insertRow(); // Add to bottom, let real-time add to top
                    row.insertCell(0).textContent = packet.timestamp;
                    row.insertCell(1).textContent = packet.source_ip;
                    row.insertCell(2).textContent = packet.destination_ip;
                    row.insertCell(3).textContent = packet.protocol;
                    row.insertCell(4).textContent = packet.source_port === 'N/A' ? '-' : packet.source_port;
                    row.insertCell(5).textContent = packet.destination_port === 'N/A' ? '-' : packet.destination_port;
                    row.insertCell(6).textContent = packet.packet_length;
                    row.insertCell(7).textContent = packet.info;
                    packetsDisplayed++;
                });
                packetCountSpan.textContent = packetsDisplayed;
            } catch (error) {
                console.error('Error loading historical packets:', error);
                packetTableBody.innerHTML = '<tr><td colspan="8" class="text-center py-4 text-gray-500">Error loading historical packets.</td></tr>';
            }

            // Load historical alerts
            try {
                const response = await fetch('/get_alerts');
                const alerts = await response.json();
                alertsList.innerHTML = '';
                if (alerts.length === 0) {
                    alertsList.innerHTML = '<p class="text-gray-600">No historical alerts.</p>';
                } else {
                    // Display alerts (assuming get_alerts returns newest first)
                    alerts.forEach(alert => {
                        const alertDiv = document.createElement('div');
                        alertDiv.className = 'bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-2 rounded-md';
                        alertDiv.innerHTML = `<p class="font-bold">${alert.alert_message}</p><p class="text-sm text-red-600">${alert.timestamp}</p>`;
                        alertsList.appendChild(alertDiv);
                    });
                }
            } catch (error) {
                console.error('Error loading historical alerts:', error);
                alertsList.innerHTML = '<p class="text-red-600">Error loading historical alerts.</p>';
            }
        }

        // Initial load
        document.addEventListener('DOMContentLoaded', () => {
            loadHistoricalData();
            loadActiveRules();
            // Trigger change event to set initial visibility of direction field
            ruleTypeSelect.dispatchEvent(new Event('change'));
        });

    </script>
</body>
</html>